# Phase 3 成果物: 入力→処理→出力フロー図

> **playbook-current-implementation-redesign Phase 3**
>
> 日時: 2025-12-09
> 目的: extension-system.md Section 1.7 に基づく Hook 連鎖の厳密な再構築

---

## 1. 全体フロー図（ASCIIart）

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     Claude Code セッションライフサイクル                      │
└─────────────────────────────────────────────────────────────────────────────┘

                              ユーザーがセッション開始
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ [1] SessionStart Hook                                                        │
│     session-start.sh                                                         │
│     ┌────────────────────────────────────────────────────────────────┐      │
│     │ 入力: { "session_id": "...", "cwd": "..." }                    │      │
│     │ 処理:                                                          │      │
│     │   1. state.md の session_tracking.last_start を更新            │      │
│     │   2. .claude/.session-init/ に pending + consent ファイル作成  │      │
│     │   3. 必須 Read 指示・CORE・[自認]テンプレートを出力            │      │
│     │ 出力: stdout（状態表示）                                       │      │
│     │ exit: 0（常に通過）                                            │      │
│     └────────────────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────────────────┘
                                       │
                                       ▼
                              ユーザーがプロンプト送信
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ [2] UserPromptSubmit Hook                                                    │
│     prompt-guard.sh                                                          │
│     ┌────────────────────────────────────────────────────────────────┐      │
│     │ 入力: { "prompt": "...", "session_id": "..." }                 │      │
│     │ 処理:                                                          │      │
│     │   1. プロンプトが project.md/playbook のスコープ内か確認       │      │
│     │   2. スコープ外の場合は警告を出力                              │      │
│     │ 出力: stdout（警告）または なし                                │      │
│     │ exit: 0（警告のみ、ブロックなし）                              │      │
│     └────────────────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────────────────┘
                                       │
                                       ▼
                          LLM がツールを使用しようとする
                                       │
                    ┌──────────────────┼──────────────────┐
                    │                  │                  │
                    ▼                  ▼                  ▼
              ┌─────────┐        ┌─────────┐        ┌─────────┐
              │  Read   │        │Edit/Write│        │  Bash   │
              └────┬────┘        └────┬────┘        └────┬────┘
                   │                  │                  │
                   ▼                  ▼                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ [3] PreToolUse(*) Hooks - 全ツール共通                                       │
│                                                                              │
│   ┌─ init-guard.sh ─────────────────────────────────────────────────────┐   │
│   │ 入力: { "tool_name": "...", "tool_input": {...} }                    │   │
│   │ 処理:                                                                │   │
│   │   - pending ファイル存在 && Read ツール                              │   │
│   │     → ファイル名を記録、全必須ファイル Read 完了で pending 削除      │   │
│   │   - pending ファイル存在 && 他ツール                                 │   │
│   │     → exit 2 でブロック                                             │   │
│   │   - pending ファイルなし → 通過                                     │   │
│   │ exit: 0（通過）または 2（ブロック）                                  │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│   ┌─ check-main-branch.sh ──────────────────────────────────────────────┐   │
│   │ 入力: { "tool_name": "...", "tool_input": {...} }                    │   │
│   │ 処理:                                                                │   │
│   │   - focus=workspace && branch=main && ツール=Edit/Write/Bash         │   │
│   │     → exit 2 でブロック                                             │   │
│   │   - それ以外 → 通過                                                 │   │
│   │ exit: 0（通過）または 2（ブロック）                                  │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                                       │
                    ┌──────────────────┼──────────────────┐
                    │                  │                  │
          ┌─────────▼─────────┐   ┌────▼────┐   ┌────────▼────────┐
          │   Edit/Write      │   │  Read   │   │      Bash       │
          │   追加 Hooks      │   │ (通過)  │   │   追加 Hooks    │
          └─────────┬─────────┘   └─────────┘   └────────┬────────┘
                    │                                    │
                    ▼                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ [4] PreToolUse(Edit/Write) Hooks - 編集系ツール専用（8個、順序厳守）         │
│                                                                              │
│   ┌─ consent-guard.sh ──────────────────────────────────────────────────┐   │
│   │ 処理: consent ファイル存在 → exit 2（[理解確認] 完了まで待機）      │   │
│   │ exit: 0（合意済み）または 2（未合意）                                │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
│                                       ↓                                      │
│   ┌─ check-protected-edit.sh ───────────────────────────────────────────┐   │
│   │ 処理: protected-files.txt に記載 → BLOCK/WARN/許可                  │   │
│   │ exit: 0（許可）または 2（BLOCK）                                    │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
│                                       ↓                                      │
│   ┌─ playbook-guard.sh ─────────────────────────────────────────────────┐   │
│   │ 処理: playbook=null → exit 2（pm 呼び出し指示）                     │   │
│   │ exit: 0（playbook あり）または 2（なし）                            │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
│                                       ↓                                      │
│   ┌─ depends-check.sh ──────────────────────────────────────────────────┐   │
│   │ 処理: playbook の depends_on をチェック、未完了 Phase → 警告        │   │
│   │ exit: 0（警告のみ）                                                 │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
│                                       ↓                                      │
│   ┌─ check-file-dependencies.sh ────────────────────────────────────────┐   │
│   │ 処理: ファイル依存関係を表示（情報提供のみ）                        │   │
│   │ exit: 0（常に通過）                                                 │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
│                                       ↓                                      │
│   ┌─ critic-guard.sh ───────────────────────────────────────────────────┐   │
│   │ 処理: state.md に "state: done" 編集 && self_complete=false         │   │
│   │       → exit 2（critic 必須）                                       │   │
│   │ exit: 0（done 変更なし or critic 済）または 2（未 critic）          │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
│                                       ↓                                      │
│   ┌─ scope-guard.sh ────────────────────────────────────────────────────┐   │
│   │ 処理: playbook.scope 外のファイル編集 → 警告                        │   │
│   │       STRICT_MODE=true の場合 → exit 2                              │   │
│   │ exit: 0（警告のみ）または 2（STRICT_MODE）                          │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
│                                       ↓                                      │
│   ┌─ executor-guard.sh ─────────────────────────────────────────────────┐   │
│   │ 処理: playbook.executor が claude_code でない場合 → 警告            │   │
│   │ exit: 0（警告のみ）                                                 │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                                       │
┌─────────────────────────────────────────────────────────────────────────────┐
│ [4'] PreToolUse(Bash) Hooks - Bash ツール専用（2個）                         │
│                                                                              │
│   ┌─ pre-bash-check.sh ─────────────────────────────────────────────────┐   │
│   │ 処理: git commit 時に check-state-update.sh を呼び出し              │   │
│   │ exit: 0（常に通過）                                                 │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
│                                       ↓                                      │
│   ┌─ check-coherence.sh ────────────────────────────────────────────────┐   │
│   │ 処理: state.md と playbook の整合性を 5 項目でチェック              │   │
│   │       1. focus と playbook の関連性                                 │   │
│   │       2. branch と playbook.branch の一致                           │   │
│   │       3. Phase 状態の整合性                                         │   │
│   │       4. done_criteria の妥当性                                     │   │
│   │       5. verification 状態                                          │   │
│   │ exit: 0（整合）または 2（不整合）                                   │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                                       │
                                       ▼
                            ツール実行（Edit/Write/Bash/Read）
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ [5] PostToolUse Hooks - ツール実行後                                         │
│                                                                              │
│   ┌─ log-subagent.sh (PostToolUse:Task) ────────────────────────────────┐   │
│   │ 処理: SubAgent 実行をログに記録（.claude/logs/subagent-dispatch.log）│   │
│   │ exit: 0（常に通過）                                                 │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│   ┌─ archive-playbook.sh (PostToolUse:Edit) ────────────────────────────┐   │
│   │ 処理: playbook 編集時、全 Phase が done かチェック                  │   │
│   │       全 done → アーカイブ提案を出力                                │   │
│   │ exit: 0（常に通過）                                                 │   │
│   └──────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
                                       │
                                       ▼
                          LLM が応答を完了しようとする
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ [6] Stop Hook                                                                │
│     stop-summary.sh                                                          │
│     ┌────────────────────────────────────────────────────────────────┐      │
│     │ 入力: { "stop_hook_active": true }                             │      │
│     │ 処理:                                                          │      │
│     │   1. 現在の playbook と Phase 情報を取得                       │      │
│     │   2. done/in_progress/pending の Phase 数をカウント            │      │
│     │   3. self_complete 状態を確認                                  │      │
│     │   4. 構造化されたサマリーを出力                                │      │
│     │ 出力: Phase 状態サマリー（ASCIIart テーブル）                   │      │
│     │ exit: 0（常に通過、ブロックなし）                              │      │
│     └────────────────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────────────────┘
                                       │
                                       ▼
                              セッション終了
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ [7] SessionEnd Hook                                                          │
│     session-end.sh                                                           │
│     ┌────────────────────────────────────────────────────────────────┐      │
│     │ 入力: { "session_id": "...", "cwd": "..." }                    │      │
│     │ 処理:                                                          │      │
│     │   1. state.md の session_tracking.last_end を更新              │      │
│     │   2. 未 push コミットがあれば警告                              │      │
│     │   3. .claude/.session-init/ をクリーンアップ                   │      │
│     │ 出力: stdout（警告がある場合）                                 │      │
│     │ exit: 0（常に通過）                                            │      │
│     └────────────────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. Hook 発火順序の決定要因

### 2.1 settings.json の登録順序が発火順序

```json
// PreToolUse(Edit) の例
{
  "matcher": "Edit",
  "hooks": [
    { "command": "bash .claude/hooks/consent-guard.sh" },      // 1番目
    { "command": "bash .claude/hooks/check-protected-edit.sh" }, // 2番目
    { "command": "bash .claude/hooks/playbook-guard.sh" },     // 3番目
    // ... 以下順番に発火
  ]
}
```

**重要**: 1 つでも `exit 2` を返すと、後続の Hook は発火せず、ツール実行もブロック。

### 2.2 matcher 優先順位

1. `*`（全ツール） → 最初に評価
2. `Edit` / `Write` / `Bash` / `Task`（具体ツール） → `*` の後に評価

### 2.3 同一 matcher 内の発火順序

settings.json の hooks 配列の順序どおり。

---

## 3. 連鎖の断絶箇所

### 3.1 UserPromptSubmit → PreToolUse(*) の間

| 区間 | 連続性 | 説明 |
|------|--------|------|
| SessionStart → UserPromptSubmit | 自動 | セッション開始後、ユーザーがプロンプトを送信 |
| UserPromptSubmit → PreToolUse | **手動** | LLM がツールを呼び出すかどうかは LLM の判断 |
| PreToolUse(*) → PreToolUse(Edit) | 自動 | ツール種別で自動分岐 |
| PreToolUse → ツール実行 | 条件付き | exit 0 で通過、exit 2 でブロック |
| ツール実行 → PostToolUse | 自動 | ツール実行後に発火 |
| Stop → SessionEnd | 自動 | エージェント停止後に発火 |

### 3.2 連鎖が切れる主要ポイント

1. **LLM が Read のみで作業完了する場合**: PreToolUse(Edit/Write) の Hook が発火しない
2. **LLM が何もツールを使わない場合**: PreToolUse 自体が発火しない
3. **exit 2 でブロックされた場合**: 後続処理が全て停止

---

## 4. 連鎖の種類

### 4.1 同一セッション内連鎖

```
SessionStart
    ↓
UserPromptSubmit (プロンプト 1)
    ↓
PreToolUse(*) → PreToolUse(Edit) → ツール実行 → PostToolUse
    ↓
UserPromptSubmit (プロンプト 2)
    ↓
PreToolUse(*) → PreToolUse(Bash) → ツール実行 → PostToolUse
    ↓
Stop
    ↓
SessionEnd
```

### 4.2 複数セッション間連鎖

```
[セッション 1]
SessionStart → ... → SessionEnd
    │
    │  state.md / playbook が永続化
    │
    ▼
[セッション 2]
SessionStart（state.md を読み込み、前回の状態を復元）→ ...
```

**永続化されるもの**:
- state.md（focus, goal, verification, session_tracking）
- playbook（Phase 状態）
- .claude/logs/（SubAgent 実行ログ）

**永続化されないもの**:
- .claude/.session-init/（セッション開始時に初期化）
- LLM のコンテキスト（/compact や /clear で消失）

---

## 5. 各 Hook の stdin JSON スキーマ

### 5.1 SessionStart / SessionEnd

```json
{
  "session_id": "string",
  "cwd": "string (絶対パス)"
}
```

### 5.2 UserPromptSubmit

```json
{
  "prompt": "string (ユーザー入力)",
  "session_id": "string"
}
```

### 5.3 PreToolUse / PostToolUse

```json
{
  "tool_name": "Read | Edit | Write | Bash | Task | ...",
  "tool_input": {
    // ツール依存
    // Edit: { "file_path": "...", "old_string": "...", "new_string": "..." }
    // Write: { "file_path": "...", "content": "..." }
    // Bash: { "command": "..." }
    // Read: { "file_path": "..." }
  }
}
```

### 5.4 Stop

```json
{
  "stop_hook_active": true
}
```

---

## 6. 判定ロジック詳細

### 6.1 init-guard.sh の判定

```
IF pending ファイルが存在:
  IF ツール名 == "Read":
    ファイル名を記録
    IF 全必須ファイルが記録済み:
      pending 削除
      exit 0
    ELSE:
      exit 0
  ELIF ツール名 == "Grep" OR "Glob":
    exit 0 (情報収集許可)
  ELIF ツール名 == "Bash" AND コマンドが git status/branch/...:
    exit 0 (git 状態確認許可)
  ELSE:
    exit 2 (ブロック)
ELSE:
  exit 0 (初期化完了)
```

### 6.2 check-coherence.sh の 5 項目チェック

| # | チェック項目 | 条件 | 結果 |
|---|-------------|------|------|
| 1 | focus ↔ playbook | active_playbooks.{focus} が playbook と一致 | 不一致 → WARN |
| 2 | branch ↔ playbook.branch | git branch と playbook.meta.branch が一致 | 不一致 → exit 2 |
| 3 | Phase 状態 | in_progress が 1 つのみ | 複数/0 → WARN |
| 4 | done_criteria 形式 | 各 done_criteria に "- " 形式 | 不正 → WARN |
| 5 | verification | self_complete=true → done 編集可能 | false → critic 要求 |

### 6.3 playbook-guard.sh の判定

```
IF file_path が state.md:
  exit 0 (デッドロック回避)

playbook = active_playbooks.{focus}

IF playbook == null OR playbook == "":
  exit 2 (ブロック、pm 呼び出し指示)
ELSE:
  exit 0 (通過)
```

---

## 7. SubAgent 呼び出しポイント

| Hook | 呼び出される SubAgent | タイミング |
|------|----------------------|----------|
| playbook-guard.sh | pm | playbook=null で exit 2 後、LLM が呼び出し |
| critic-guard.sh | critic | self_complete=false で exit 2 後、LLM が呼び出し |
| check-coherence.sh | coherence | 警告後、LLM が判断して呼び出し |
| (CLAUDE.md) | state-mgr | state.md 操作時に LLM が呼び出し |

**注意**: Hook 自体が SubAgent を呼び出すのではなく、Hook がブロック/警告 → LLM が SubAgent を呼び出す、という流れ。

---

## 変更履歴

| 日時 | 内容 |
|------|------|
| 2025-12-09 | Phase 3 完了。入力→処理→出力フロー図を ASCIIart で作成。連鎖の断絶箇所と判定ロジックを明記。 |

---

**作成日時**: 2025-12-09
**作成者**: Claude Code（P3 実行）
**状態**: ✅ 完了、Phase 4 へ移行可能
